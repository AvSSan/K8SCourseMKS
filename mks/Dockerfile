# --- ЭТАП 1: СБОРКА (BUILD) ---
# Мы берем образ, в котором уже есть Maven и Java. Назовем этот этап "builder"
FROM maven:3.9.6-eclipse-temurin-17 AS builder

# Устанавливаем рабочую папку внутри "сборочного" контейнера
WORKDIR /app

# Сначала копируем только файл настроек сборки pom.xml
COPY pom.xml .

# Скачиваем все библиотеки (зависимости) заранее.
# Это нужно, чтобы Docker "закешировал" их. Если ты поменяешь код, но не библиотеки,
# этот долгий шаг пропустится при следующей сборке.
RUN mvn dependency:go-offline

# Теперь копируем твой исходный код (папку src) внутрь контейнера
COPY src ./src

# Запускаем команду сборки.
# clean - чистит старое, package - упаковывает в .jar
# -DskipTests - пропускаем тесты, чтобы сэкономить время при обучении
RUN mvn clean package -Dmaven.test.skip=true

# --- ЭТАП 2: ЗАПУСК (RUN) ---
# Берем другой, легкий образ. В нем есть только Java Runtime (JRE), без Maven.
FROM eclipse-temurin:17-jre-alpine

# Указываем рабочую папку для финального приложения
WORKDIR /app

# Самый важный момент!
# Мы копируем ГОТОВЫЙ .jar файл из этапа "builder" (см. первую строку) в текущий образ.
# Мы переименовываем его в app.jar, чтобы было проще запускать.
COPY --from=builder /app/target/*.jar app.jar

# Говорим Docker'у, что наше приложение слушает порт 8081 (как в application.properties)
EXPOSE 8081

# Команда, которая сработает при запуске контейнера: "java -jar app.jar"
ENTRYPOINT ["java", "-jar", "app.jar"]